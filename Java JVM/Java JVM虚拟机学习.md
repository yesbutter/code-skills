@[TOC](目录)

## 推荐阅读书籍 
《深入理解java虚拟机》[提取码dg9o](https://pan.baidu.com/s/1VA1ql9iSQCgHrAV_UEecrQ)
   
# Java JVM虚拟机学习

## 1.什么是JVM虚拟机

Java的运行的一个平台


## 2.内存管理机制

### 2.1  Java内存区域

- 方法区

  是线程共享的一块区域。
  用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后代码的数据。
  在HotSpot当中也被成为是永久代

- 运行时常量池

	 存储编译期生成的各种字面量和符号引用。
	 具备动态性，Java语言不要求常量一定只有编译期才能产生，运行期间也可以放入(String类的intern()方法，可以运行期间将字符串放入常量池中)

- 堆

  Java虚拟机管理的内存最大的一块，被所有线程共享的一块内存区域。Java堆是垃圾收集器管理的最主要区域。
  Java堆可以分配在物理上不连续的内存空间，只要逻辑上是连续的即可。

	- 新生代

	  Eden、survivor1、survivor2
	  默认占比8:1:1

	- 老年代

	  新生代:老年代 1:2

- 虚拟机栈

  也是由线程进行管理的。一个线程一个虚拟机栈。虚拟机栈描述的是Java方法执行的内存模型，每个方法执行的同时会创建栈帧()用来存储局部变量、操作数栈、动态连接、方法出口

	- 栈帧

	  在执行方法的时候会创建栈帧

		- 局部变量表

		  局部变量表占多少插槽。
		  在编译的时候确定占据多大。

		- 操作数栈

		  完成数值赋值的一块区域

		- 动态连接

		  指向运行时常量池中该栈帧所属方法的引用

		- 返回地址 恢复现场
		- 其他信息

		  调试信息等等

- 本地方法栈

  与虚拟机栈相似，不过执行的是c/c++代码方法

- 程序计数器

  程序计数器是用来指示程序所要执行字节码的行号指示器。由线程进行管理。由执行引擎操作

- 直接内存

  并不属于JVM虚拟机运行时数据区的部分，是通过Unsafe(魔术)类生成的本地当中的内存
Java的运行的一个平台
### 2.2  对象

- 对象创建

	- 加载判断

	  首先检测常量池中是否有类的符号引用，检查这个类是否被加载，解析，初始化过。如果没有就执行相应的类加载过程。

	- 内存分配

	  虚拟机为对象分配内存，大小由加载完成后确定。分配方法有指针碰撞，空闲列表俩种

		- 指针碰撞

		  假设Java虚拟机中堆内存是规整的，用过的空间放在一起，空闲的放在另一边。中间存放一个指针作为分界点指示器。
		  分配内存就是把分界点指示器向空闲区域移动创建大小的相等的距离。

		- 空闲列表

		  假设Java虚拟机堆内存不完整，使用和空闲的区域交错。
		  虚拟机维护一个列表，记录那些空间是可用的，内存分配时，就把分配一块与对象大小相等的一块空闲区域，并更新表上的记录。

		- 内存分配并发控制

			- CAS+不断重试
			- 本地线程分配缓存

			  每个线程固定分配一个大小的区域，创建对象的时候，会首先对这块区域进行操作，如果区域满之后再进行同步锁定。
			  可以通过-XX：+/-UseTLAB 参数设定大小

	- 对象头填充

	  把信息放入到对象的对象头当中。
	  对象是那个类的实例
	  如何找到类的元数据信息
	  对象的哈希码
	  对象的GC分代年龄
	  是否启用偏向锁 等等

	- <init>方法执行

- 对象内存区域

	- 对象头

	  HotSpot当中分成俩部分内容。
	  1.存储对象自身运行时数据。如:哈希码、GC分代年龄、锁状态标志、线程持有锁、锁偏向ID、偏向时间戳
	  2.类型指针，即对象指向类元数据的指针

	- 实例数据

	  对象的有效信息，Hotspot存储分配策略是按顺序longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers)
	  父类的变量分配在子类之前。
	  如果CompactFileds 设置为true，子类较窄的变量会穿插在父类的变量空隙中

	- 对齐填充

	  占位符，方便内存管理。对象大小必须是8字节的整数倍

- 对象的访问定位

	- 使用句柄访问

	  划分出一块内存作为句柄池，reference当中存储的就是对象的句柄地址。相当于一个二次指针。
	  好处是可以存储对象的位置，也可以存储对象实例数据。
	  也可以对对象的移动修改简单，只需要改变句柄值

	- 直接指针访问

	  直接存放对象的地址。
	  需要考虑如何找到对象的实例数据。这样速度更快，对象的访问在Java中非常频繁

### 2.3  OutOfMemoryException

- Java堆溢出

  不断创建对象，并且保证GC root到对象有可达路径，避免垃圾回收。当达到堆的最大大小就会产生内存溢出异常。
  异常信息 java.lang.OutOfMemoryException
  Java heap space
  解决方案
  1.是否出现内存泄露
  2.内存溢出，可以调大虚拟机堆参数 或者检查某些大对象生命周期过长，减少程序内存运行时消耗

- 虚拟机栈和本地方法栈溢出

  1.线程请求栈深度大于虚拟机所运行的最大深度。StackOverflowException
  2.虚拟机在扩展栈时无法申请到足够的内存空间.OutOfMemoryException
  1发生在单线程。
  2.发生在多线程
  解决方案
  使用-Xss栈内存容量

- 方法区和运行时常量池溢出

  常量池的大小超过设定值
  操作提示:PermGen space
  
  设置-XX:PermSize和-XX:MaxPermSize

- 本机内存直接溢出

  Unsafe类的getUnsafe()方法只有引导类加载器才能使用Unsafe的功能。
  真正分配内存的方法是
  unsafe.allocateMemory()。
  错误提示 Unsafe.allocateMemory()
  -XX:MaxDirectMemorySize 如果不指定和Java堆最大值一样
  可能情况,直接或者间接使用NIO

## 3.垃圾收集器与内存分配策略

### 3.1  那些内存需要回收

- 怎么判断对象已死

	- 引用计数算法

	  每当引用的时候计数器值加一，引用失效值减一。
	  不能解决循环依赖问题

	- 可达性算法Gc root

	  通过一系列"GC Roots"对象作为起始点，从这些节点开始向下搜索，走过的路径成为引用链。当一个对象到GC root没有路径，证明对象不可达，就是可回收的对象
	  可以作为GC root的对象有
	  1.虚拟机栈中引用的对象
	  2.方法区中类的静态属性引用的对象
	  3.方法区中常量引用的对象
	  4.本地方法栈中JNI引用的对象

- Java对象的4种类型

	- 强引用

	  对象的创建。
	  只要存在引用就不会被回收

	- 软引用

	  有用但非必须的对象。
	  在发生内存溢出之后，还是空间不够，再次进行GC的时候会被回收掉。

	- 弱引用

	  非必须对象。
	  遇到GC就会被回收

	- 虚引用

	  最弱的依赖关系。随时可能会被回收，在被回收时会进行系统通知。

- 方法区

  永久代回收效率低与堆的效率。大部分内容是不会被回收。
  主要有俩部分内容：
  废弃常量和无用类。

	- 无用类

	  该类的所有实例都被回收
	  加载该类的加载器被回收
	  该类在任何地方都没有引用，无法在任何地方通过反射访问该方法的类

	- 废弃常量

	  没有引用这个常量的值

### 3.2  垃圾收集算法

- 标记-清除

  1.标记所有需要回收的对象
  2.清除标记的对象。
  
  缺点:
  1.效率不高，标记和清除都比较花时间
  2.空间问题。会导致大量的空间碎片，在对大对象的创建的时候会再次触发GC

- 复制

  将空间分成俩部分，存储时把内容放入到一个区域。
  发生GC时将存储区域的所有存活对象复制到另一个区域，清除掉存储对象的区域。
  
  HotSpot 不是按1:1分配。
  因为研究表明每次GC的对象98%的都会被回收
  而是分配8:1:1 Eden：Survivor0:Survivor1
  当GC之后的对象无法存放进Survivor1会放入到老年代当中

- 标记-整理

  根据老年代的特点，并不是大部分内容会被清理
  1.标记存活对象
  2.把所有存活对象移到一端，清除掉边界以外的所有内存

- 分代收集

  根据老年代和新生代的特定使用对象的处理策略

### 3.3  HotSpot算法实现

- 枚举根节点

  从可达性分析中从GC roots节点找引用链的操作，逐个查找这些引用。
  GC分析的时候会停止Java执行线程。（Stop the World）

- 安全点

  指令的执行会导致引用关系的变化，程序在“特定的位置”进行停顿，这些位置成为安全点，

	- 抢先式中断

	  GC停止线程运行时，发现不在安全点时，会让线程继续跑到安全点

	- 主动式中断

	  设置访问标志，线程执行时主动去轮询标志，发现为真时，就将自己挂起。轮询标志的地方和安全点重合

- 安全区域

  扩展的安全点

### 3.4  垃圾收集器

- Serial

  JDK1.3新生代收集器的唯一选择。
  单线程收集器，在gc操作的时候会Stop the world，虚拟机后台将所有用户正常工作的线程停掉。
  新生代采用复制算法
  
  serial old采用标记-整理

- Serial Old

  老年代版本的Serial 使用标记-整理算法

- ParNew

  多线程版本的serial

- Parallel Scavenge

  Parallel Scavenge收集器是一个新生代收集器，使用复制算法，并行的多线程收集器。
  Parallel Scavenge目标是达到一个可控制的吞吐量。吞吐量=运行用户的代码/（运行用户的代码+垃圾收集时间）
  Parallel Scavenge提供了俩个参数用于精确控制吞吐量
  最大垃圾手机停顿时间: -XX:MaxGCPauseMillis
  吞吐量大小-XX:GCTimeRato

- Parallel Old

  Parallel Scavenge的老年代版本使用多线程 标记整理

- CMS

  ConCurrent Mark Swap 是一种获取最短停顿时间为目标的收集器。
  集中在互联网网站和B/S架构的服务端上。
  基于标记-清除。
  
  缺点:
  1.CPU资源敏感，默认启动的线程数是(CPU数量+3)/4，当CPU数量不多时，可能会导致用户执行线程速度下降。
  2.空间碎片，因为标记-清除。可以设定指定多次不压缩的Full Gc之后带来一次压缩的。
  3.无法处理浮动垃圾 并发清理的时候运行的线程也在运行，这个时候产生的垃圾无法被处理。 可以设定老年代的大小触发GC的百分比。 -XX：CMSInitationOccupancyFratcion的值提高触发的百分比

	- 初始标记

	  标记GC Roots关联到的对象，速度很快

	- 并发标记

	  GC Roots 遍历的过程

	- 重新标记

	  修正并发标记期间用户程序运作导致的对象变化的内容

	- 并发清除

- G1收集器

  GarBage-First收集器是当今收集器/技术发展最前沿的结果。Sun公司给出的JDK1.7。G1是一款面向服务端应用的垃圾收集器
  优点
  1.并发与并行。充分利用多CPU、多核环境下的硬件优势、使用多个CPU减少Stop the World的时间
  2.分代收集
  3.空间整合
  4.可预测停顿
  G1收集器将Java堆内存布局进行划分成多个大小相等的独立区域(Region)，保留新生带和老年代，它们都是一部分Region集合
  G1收集器中Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用。避免全堆扫描，m每个region中都会有对应的Remembered Set,虚拟机发现程序在对Refernce类型的数据进行写操作时，会产生一个Write Barrier暂时中段写操作，检查引用是否在不同的region当中

	- 初始标记
	- 并发标记
	- 最终标记
	- 筛选回收

	  对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿时间来指定回收计划。

### 3.5  内存分配与回收策略

- 优先在Eden分配
- 大对象直接进入老年代

  可以通过设定参数-XX：PretenureSizeThreshold参数大于这个大小的直接分配在老年代

- 长期存活对象进入老年代

  在新生代当中的对象熬过一次Minor Gc年龄会加一，经过15次时候会被放入到老年代。

	- 动态对象年龄判定

	  如果在Suvivor的对象相同年龄的对象占具Suvivor对象的一半，会把这些内容直接放入老年代

- 空间分配担保

  发生Minor GC(young GC) 发生GC之后新生代 Survivor1无法放入的对象会被放到老年代当中。
  GC之后会进行检测是否老年代中是否够放，不够就会触发一次Full GC

## 4.虚拟机性能监测与故障处理工具

-  jps

JVM Process Status Tool 显示指定系统内所有的HotSpot虚拟机进程

-  jstat

JVM Statistics Monitoring Tool,用于收集HotSpot虚拟机各方面运行时的数据

-  jinfo

Configuration Info for Java 显示虚拟机配置信息

-  jmap

Memory Map for Java 生成虚拟机的内存存储快照

-  jhat

JVM Heap Dump Browser 用于分析heapdump文件，会创建一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果

-   jstack

Stack Trace for Java 显示虚拟机的线程快照

-  VisualVM 多合一故障处理工具

## 5.虚拟机类加载机制

### 5.1  类加载

类被加载到虚拟机内存的生命周期有。加载，验证，准备，解析，初始化，使用，卸载

- 加载

  Java虚拟机规范中并没有进行强制约束，交给虚拟机的具体实现来把握

	- 通过一个类的全限定名来获取定义次类的二进制流
	- 将这个字节流转化为方法区的数据结构
	- 在内存中生成一个代表这个类的对象，作为方法区这个类的访问入口。

- 验证

  确保class文件的字节流中包含的信息符合虚拟机的要求。并且不会危害虚拟机的安全

	- 文件格式验证
	- 元数据验证
	- 字节码验证
	- 符号引用验证

- 准备

  准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量的内存都将在方法区中进行分配，将对象赋值为对应的0值

- 解析

  解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
  符号引用用一组符号表示引用的目标。
  直接引用是直接指向目标的指针
  类或接口的解析

	- 字段解析
	- 类方法解析
	- 接口方法解析

- 初始化

  类加载过程的最后一部，在初始化阶段。执行类加构造器<clinit>方法的过程

- 使用
- 卸载

### 5.2  类加载器

- 类与类加载器

  判断俩个类相等，需要判断类是否相等，判断俩个类的加载器是否一样

- 双亲委派模型

  如果一个类加载器收到了类加载的请求，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有加载请求最终都会传到顶层的启动类加载器。只有父加载器反馈无法完成这个加载请求，子加载器才会方式自己去加载。
  好处：保证对象类在程序当中都是同一个类，如果各个类加载器去自行加载，就会导致产生多个相同名称，不相等的类

- 热修复

## 6.程序编译与代码优化

### 6.1  注解处理器

### 6.2  语义分析与字节码生成

- 标注检查
- 数据及控制流分析
- 解语法糖
- 字节码生成

### 6.3  Java语法糖

- 泛型与类型擦除

  没引入之后，把类型转化交给程序员，把ClassCastException
  泛型是在JDK1.5引入的新特性。
  Java语言的泛型只存在程序源码中，在编译后的字节码文件，已经被替换为原声类型。并在相应的地方插入强制转化。

- 自动装箱，拆箱 遍历循环
- 条件编译

### 6.4  运行期优化

## 7.高效并发

并发处理，提高计算机的运算能力

### 7.1  Java内存模型与线程

- Java内存模型

  主要目标是定义程序中各个变量的访问规则。规定了主内存和每条线程的工作内存

	- 主内存和工作内存

	  工作内存会首先从主内存当中取值

	- 内存间的交互操作

	  1.不允许read和load、store和write操作之一单独出现。
	  2.不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把改变化同步到主内存。
	  3.不允许一个线程无原因地把数据从工作线程写入到主内存中
	  4.一个新的变量只能从主内存中"诞生"，不允许工作内存直接使用一个未被初始化的变量
	  5。一个变量在同一时刻只允许一条线程进行lock操作
	  6.变量执行lock操作，会清空工作内存中此变量的值。在使用这个变量前，需要重新执行load或assign操作变量的初始值
	  7.一个变量没有被lock,不允许unlock
	  8.unlock之前必须把数据写入到主内存

		- lock(锁定)

		  作用于主内存的变量，它把一个变量标识为一条线程独占的状态

		- unlock(释放)

		  作用于主内存的变量，把一个处于锁定的状态的变量释放出来，释放后的变量才可以被其他线程锁定

		- read(读取)

		  作用于主内存的变量，它把一个变量的值从主内存传输到线程工作的内存，以便随后的load动作使用

		- load(载入)

		  作用与工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中

		- use(使用)

		  作用于工作内存的变量，把工作内存中的一个变量的值传递给引擎，m每当虚拟机遇到一个需要使用的变量的值的字节码指令时将会执行这个操作。

		- assign(赋值)

		  作用于工作内存的变量，它把一个执行引擎j接收到的值赋值给工作内存的变量，每当虚拟机遇到一个变量赋值的字节码指令执行这个操作

		- store(存储)

		  作用于工作内存内，把工作内存的一个值写入到主内存中，以便随后的write操作使用

		- write(写入)

		  作用于主内存，它把store操作从工作内存取到的变量的值写入到主内存的变量中。

	- volatile

		- 可见性
		- 禁止指令重排
		- 不保证原子性

	- 存在的问题

		- 先行发生

		  i=1 ;//线程A
		  
		  j=i；//线程B
		  
		  i=2; //线程C
		  这个三个线程执行会发生不确定性的结果

- 线程

	- 使用内核线程实现

	  直接由操作系统内核执行的线程，
	  这种线程由内核来完成线程的切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。
	  程序一般不会使用内核线程

	- 使用用户线程实现

	  一个线程只要不是内核线程，就是用户线程。
	  轻量级的进程也是属于线程。用户线程的建立，同步，销毁和调度完全由用户态执行支持规模大的线程数量。

	- 使用用户线程和轻量级进程混合实现

	  用户线程和轻量级进程混合使用。N:M关系

	- Java线程的实现

	  sun JDK 一条Java线程映射到一条轻量级进程

    - 线程调度

        - 协同式调度

			  一个线程决定自己执行多久。工作完之后同时其他线程。
			  实现简单。
			  缺点是 相当不稳定，一个线程不让出资源，其他都会阻塞

		- 抢占式线程调度

			  由系统分配执行时间，通过设置优先级表示抢占的之后的执行时间

		- 线程状态

			- 新建

			  创建尚未启动

			- 运行

			  有可能在执行，也可能在等待CPU为它分配时间

			- 无限期等待

			  不会被分配执行时间，要等待被其他线程显式的唤醒。
			  没有Timeout参数的Object,wait()
			  没有Timeout参数的Thread,join()
			  LockSupport.park()方法

			- 限期等待

			  不会被CPU分配执行时间，不需要等待其他线程显式唤醒。在执行一定时间之后会由系统自动唤醒。
			  Thread.sleep()
			  设置参数的Object.wait()
			  设置参数的Thread.join()
			  LockSupport.parkNanos()
			  LockSupport.parkUntil()

			- 阻塞

			  等待获取一个排他锁

			- 运行

			  执行结束

### 7.2  线程安全与锁优化

- 线程安全

  当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

	- 互斥同步

	  互斥是保证同步的方法

		- 临界区
		- 互斥量
		- 信号量
		- synchornized
		- lock

	- 非阻塞同步

		- 测试并设置
		- 获取并增加
		- 交换
		- 比较并交换CAS

		  Unsafe类下提供的方法。
		  compareAndSwapInt()和
		  compareAndSwapLong()

		- 加载链接/条件存储

	- 无同步方案

	  如果一个方法本来就不设计共享数据无需同步措施去保证正确性，有一些代码天生就是线程安全的

		- 可重入代码
		- 线程本地存储

- 锁优化

  互斥同步的最大性能消耗是挂起线程和恢复线程操作都需要转入到内核态，给操作系统带来压力。

	- 自旋锁与自适应自旋

	  可以设置参数设定自旋次数

	- 锁消除

	  虚拟机检测到不可能存在共享数据竞争，会把锁进行消除。

	- 锁粗化

	  一系列操作对一个对象的反复加锁和解锁，即使没有线程竞争，频繁执行互斥同步操作导致不必要的性能消耗。
	  如StringBuilder的append方法。

	- 轻量级锁

	  如果存在锁竞争，除了互斥开销，还发生了CAS，轻量级锁比传统的重量级锁更慢

	- 偏向锁

	  消除无竞争状态下的同步原语。
	  锁会偏向第一个获取它的线程


## JVM 相关面试题

### 1.一个方法执行完之后JVM会做什么处理

- 虚拟机栈中栈帧空间回收
- 该方法返回地址入栈
- 局部变量表重置
- 操作数栈表重置
- 程序计数器重置

### 2.同步指令synchorized 在JVM层面上的理解

Java虚拟机使用管程支持同步的。
虚拟机可以从方法的常量池的方法表结构中的ACC_SYNCHRONIZED的访问标识判断方法是否是同步方法

当方法调用时，调用指令将会检查ACC_SYNCHRONIZED访问标志是否被设置了，如果设置了，执行线程就要求先持有管程，执行线程持有了管程，其他任何线程无法再获取同一个管程。如果一个同步方法出现了异常，这个管程将在异常抛到同步方法之外时自动释放。

同步一端指令集序列通常是由Java语言中的synchronized语句块来表示，Java指令集中有monitorEnter和monitorExit俩条指令来支持synchronized关键字的语义。

