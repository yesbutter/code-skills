# 目录

* [Java JVM虚拟机学习](#java-jvm虚拟机学习)
  * [1  JVM](#1--jvm)
  * [2  内存管理机制](#2--内存管理机制)
    * [2.1  Java内存区域](#21--java内存区域)
    * [2.2  对象](#22--对象)
    * [2.3  OutOfMemoryException](#23--outofmemoryexception)
  * [3.垃圾收集器与内存分配策略](#3垃圾收集器与内存分配策略)
    * [3.1  那些内存需要回收](#31--那些内存需要回收)
    * [3.2  垃圾收集算法](#32--垃圾收集算法)
    * [3.3  HotSpot算法实现](#33--hotspot算法实现)
    * [3.4  经典垃圾收集器](#34--经典垃圾收集器)
    * [3.5  内存分配与回收策略](#35--内存分配与回收策略)
  * [4.虚拟机性能监测与故障处理工具](#4虚拟机性能监测与故障处理工具)
    * [jps](#jps)
    * [jstat](#jstat)
    * [jinfo](#jinfo)
    * [jmap](#jmap)
    * [jhat](#jhat)
    * [jstack](#jstack)
    * [VisualVM 多合一故障处理工具](#visualvm-多合一故障处理工具)
  * [5.虚拟机类加载机制](#5虚拟机类加载机制)
    * [5.1  类加载](#51--类加载)
    * [5.2  类加载器](#52--类加载器)
  * [6.程序编译与代码优化](#6程序编译与代码优化)
    * [6.1  注解处理器](#61--注解处理器)
    * [62  语义分析与字节码生成](#62--语义分析与字节码生成)
    * [Java语法糖](#java语法糖)
    * [运行期优化](#运行期优化)
  * [7.高效并发](#7高效并发)
    * [7.1  Java内存模型与线程](#71--java内存模型与线程)
    * [线程安全与锁优化](#线程安全与锁优化)

  * [JVM 相关面试题](#jvm-相关面试题)
    * [1.一个方法执行完之后JVM会做什么处理](#1一个方法执行完之后jvm会做什么处理)
    * [2.同步指令synchorized 在JVM层面上的理解](#2同步指令synchorized-在jvm层面上的理解)

## 推荐阅读书籍 
《深入理解java虚拟机》[提取码dg9o](https://pan.baidu.com/s/1VA1ql9iSQCgHrAV_UEecrQ)## xmind在同级目录下，需要自取。

# Java JVM虚拟机学习

## 1  JVM

JVM是Java Virtual Machine的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。

## 2  内存管理机制

### 2.1  Java内存区域

- 2.1.1  方法区

  方法区是线程共享内存的一块区域。
  方法区用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后代码的数据。
  在HotSpot JDK8之前为永久代
  JDK8之后为元空间，存储空间移到了本机内存当中。

- 2.1.2  堆

  Java虚拟机管理的内存最大的一块，被所有线程共享的一块内存区域。几乎所有的对象实例以及数组都应当在堆上分配。(栈上分配，标量替换)。
  Java堆在HotSpot虚拟机中被划分为老年代:新生代（2：1）。新生代又被分为Eden空间，From Survivor,To Survivor（8：1：1）

	- 老年代
	- 新生代

		- Eden
		- From Survivor
		- To Survivor

	- 运行时常量池

	  JDK8之前这部分内容不被放在堆中存储。
	  存储编译期生成的各种字面量和符号引用
	  具备动态性，Java语言不要求常量一定只有编译期才能产生，运行期间也可以放入(String类的intern()方法，可以运行期间将字符串放入常量池中)

- 2.1.3  虚拟机栈

  虚拟机栈描述的是Java方法的内存模型。每个方法执行后会创建一个栈帧，栈帧的结构如下：

	- 局部变量表

	  局部变量表占多少插槽。
	  在编译的时候确定占据多大。
	  局部变量表的插槽是可复用的。

	- 操作数栈

	  操作栈，在方法执行过程中会有各种字节码指令往操作数栈中写入和提取内容。
	  操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配。
	  Java虚拟机也被成为基于栈的执行引擎

	- 动态连接

	  指向运行时常量池中该帧所属方法的引用

	- 返回地址 恢复现场
	- 其他信息

	  调试信息等等

- 2.1.3  本地方法栈

  与虚拟机栈相似。虚拟机栈指定的是本地方法。

- 2.1.4  程序计数器

  程序计数器指向当前线程所执行字节码行号。可以通过更改程序计数器的值来选取下一条需要执行的字节码指令，分支，跳转，循环，异常处理，线程恢复等功能都需要依赖这个计数器来完成。

- 2.1.5  直接内存

  并不属于JVM虚拟机运行时数据区的部分。在JDK1.4中加入NIO类，引入基于通道与缓冲区IO的方式，可以使用Native函数库直接分配堆外内存。

### 2.2  对象

- 2.2.1  对象创建

	- 加载判断

	  首先检测常量池中是否有类的符号引用，检查这个类是否被加载，解析，初始化过。如果没有就执行相应的类加载过程。

	- 内存分配

	  加载完成后，虚拟机为对象分配内存，大小由加载完成后确定。分配方法有指针碰撞，空闲列表俩种.
	  分配策略由Java堆是否规整，堆是否规整取决于垃圾回收期是否带空间压缩整理觉得的。

		- 指针碰撞

		  假设Java虚拟机中堆内存是规整的，用过的空间放在一起，空闲的放在另一边。中间存放一个指针作为分界点指示器。
		  分配内存就是把分界点指示器向空闲区域移动创建大小的相等的距离。

		- 空闲列表

		  假设Java虚拟机堆内存不完整，使用和空闲的区域交错。
		  虚拟机维护一个列表，记录那些空间是可用的，内存分配时，就把分配一块与对象大小相等的一块空闲区域，并更新表上的记录。

		- 内存分配并发控制

			- CAS+不断重试
			- 本地线程分配缓存

			  每个线程固定分配一个大小的区域(TLAB)，创建对象的时候，会首先对这块区域进行操作，如果区域满之后再进行同步锁定。
			  可以通过-XX：+/-UseTLAB 参数设定大小

	- 对象头填充

	  把信息放入到对象的对象头当中。
	  对象是那个类的实例
	  如何找到类的元数据信息
	  对象的哈希码
	  对象的GC分代年龄
	  是否启用偏向锁 等等

	- <init>方法执行

	  按照程序员编写的内容进行初始化，构成一个真正的对象。

- 2.2.2  对象内存布局

	- 对象头

	  HotSpot当中分成俩部分内容。
	  1.存储对象自身运行时数据。如:哈希码、GC分代年龄、锁状态标志、线程持有锁、锁偏向ID、偏向时间戳
	  2.类型指针，即对象指向类元数据的指针

	- 实例数据

	  对象的有效信息，我们在程序代码中定义的各种类型的字段内容。
	  这些内容的分配策略会收虚拟机分配策略和定义顺序影响。Hotspot存储分配策略是按顺序longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers)
	  父类的变量分配在子类之前。
	  如果CompactFileds 设置为true，子类较窄的变量会穿插在父类的变量空隙中

	- 对齐填充

	  占位符，方便内存管理。对象大小是8字节的整数倍。

- 2.2.3  对象的访问定位

	- 使用句柄访问

	  划分出一块内存作为句柄池，reference当中存储的就是对象的句柄地址。相当于一个二次指针。
	  好处是可以存储对象的位置，也可以存储对象实例数据。
	  也可以对对象的移动修改简单，只需要改变句柄值

	- 直接指针访问

	  直接存放对象的地址。
	  需要考虑如何找到对象的实例数据。这样速度更快，对象的访问在Java中非常频繁

### 2.3  OutOfMemoryException

详细实验在JVM代码中有实践。

- Java堆溢出

  不断创建对象，并且保证GC root到对象有可达路径，避免垃圾回收。当达到堆的最大大小就会产生内存溢出异常。
  异常信息 java.lang.OutOfMemoryException
  Java heap space
  解决方案
  1.是否出现内存泄露
  2.内存溢出，可以调大虚拟机堆参数 或者检查某些大对象生命周期过长，减少程序内存运行时消耗

- 虚拟机栈和本地方法栈溢出

  1.线程请求栈深度大于虚拟机所运行的最大深度。StackOverflowException
  2.虚拟机在扩展栈时无法申请到足够的内存空间.OutOfMemoryException
  1发生在单线程。
  2.发生在多线程
  解决方案
  使用-Xss栈内存容量

- 方法区和运行时常量池溢出

  常量池的大小超过设定值
  操作提示:PermGen space
  
  设置-XX:PermSize和-XX:MaxPermSize

- 本机内存直接溢出

  Unsafe类的getUnsafe()方法只有引导类加载器才能使用Unsafe的功能。
  真正分配内存的方法是
  unsafe.allocateMemory()。
  错误提示 Unsafe.allocateMemory()
  -XX:MaxDirectMemorySize 如果不指定和Java堆最大值一样
  可能情况,直接或者间接使用NIO

## 3.垃圾收集器与内存分配策略

### 3.1  那些内存需要回收

- 3.1.1  怎么判断对象已死

	- 引用计数算法

	  每当引用的时候计数器值加一，引用失效值减一。
	  不能解决循环依赖问题

	- 可达性算法Gc root

	  通过一系列"GC Roots"对象作为起始点，从这些节点开始向下搜索，走过的路径成为引用链。当一个对象到GC root没有路径，证明对象不可达，就是可回收的对象
	  可以作为GC root的对象有
	  1.虚拟机栈中引用的对象
	  2.方法区中类的静态属性引用的对象
	  3.方法区中常量引用的对象
	  4.本地方法栈中JNI引用的对象
	  5.所有同步锁持有的对象

- 3.1.2  Java对象的4种类型

	- 强引用

	  对象的创建。
	  只要存在引用就不会被回收

	- 软引用

	  有用但非必须的对象。
	  在发生内存溢出之后，还是空间不够，再次进行GC的时候会被回收掉。

	- 弱引用

	  非必须对象。
	  遇到GC就会被回收

	- 虚引用

	  最弱的依赖关系。随时可能会被回收，在被回收时会进行系统通知。

- 3.1.3  方法区

  永久代回收效率低与堆的效率。大部分内容是不会被回收。
  主要有俩部分内容：
  废弃常量和无用类。

	- 无用类

	  该类的所有实例都被回收
	  加载该类的加载器被回收
	  该类在任何地方都没有引用，无法在任何地方通过反射访问该方法的类

	- 废弃常量

	  没有引用这个常量的值

### 3.2  垃圾收集算法

- 3.2.1  标记-清除

  1.标记所有需要回收的对象
  2.清除标记的对象。
  
  缺点:
  1.效率不高，标记和清除都比较花时间
  2.空间问题。会导致大量的空间碎片，在对大对象的创建的时候会再次触发GC

- 3.2.2  复制

  将空间分成俩部分，存储时把内容放入到一个区域。
  发生GC时将存储区域的所有存活对象复制到另一个区域，清除掉存储对象的区域。
  
  HotSpot 不是按1:1分配。
  因为研究表明每次GC的对象98%的都会被回收
  而是分配8:1:1 Eden：Survivor0:Survivor1
  当GC之后的对象无法存放进Survivor1会放入到老年代当中

- 3.2.3  标记-整理

  根据老年代的特点，并不是大部分内容会被清理
  1.标记存活对象
  2.把所有存活对象移到一端，清除掉边界以外的所有内存

- 3.2.4  分代收集理论

  建立在俩个分代假说之上:
  1.绝大部分对象都是朝生夕灭
  2.熬过多次垃圾收集过程难以消亡
  
  新生代GC MinorGC/YoungGC
  老年代GC MajorGC/OldGC
  整堆收集 Full GC
  
  G1收集器 还有Mixed GC 整个新生代和部分老年代
  只对新生代GC会存在老年代的对象有引用的，还需要额外遍历老年代，反过来也一样。
  3 跨代引用占极少数
  策略是在新生代上建立一个全局数据结构 记忆集。当进行新生代的扫描时，包含跨代引用关系会进行GC root的扫描。

### 3.3  HotSpot算法实现

- 3.3.1  枚举根节点

  从可达性分析中从GC roots节点找引用链的操作，逐个查找这些引用。
  GC分析的时候会停止Java执行线程。（Stop the World）
  使用一组OopMap的数据结构。类加载完成的时候虚拟机把对象的数据计算出来，会在特定的位置和栈里标记那些位置是引用。

- 3.3.2  安全点

  根节点枚举完毕。但是导致OopMap内容变化的指令非常多，每一条都生成对应的OopMap会需要大量的存储空间。
  程序在特定的位置、生成OopMap这些点被成为安全点。安全点的选定会影响到垃圾收集，不能太少垃圾收集器等待时间长、不能太多会频繁的增大运行时内存。
  还需要让垃圾收集的时候让所有线程都跑到安全点、停顿下来。有以下俩种方法：主动式中断、抢先式中断。

	- 抢先式中断

	  GC停止线程运行时，发现不在安全点时，会让线程继续跑到安全点

	- 主动式中断

	  设置访问标志，线程执行时主动去轮询标志，发现为真时，就将自己挂起。轮询标志的地方和安全点重合

- 3.3.3  安全区域

  安全点保证了程序在运行时能够正常处理。
  但是程序不执行的时候，就需要安全区域来解决。
  安全区域是确定在某一段代码中，引用关系不会发生变化，在这个区域内回收垃圾都是安全的。

- 3.3.4 记忆表和卡表

  记忆表是记录非收集区域指向收集区域的抽象数据结构。

- 3.3.5  并发可达性分析

### 3.4  经典垃圾收集器

- Serial

  JDK1.3新生代收集器的唯一选择。
  单线程收集器，在gc操作的时候会Stop the world，虚拟机后台将所有用户正常工作的线程停掉。
  新生代采用复制算法

- Serial Old

  老年代版本的Serial 使用标记-整理算法

- ParNew

  并行版本的serial。并行是指用户线程暂停，多个serial线程共同执行。

- Parallel Scavenge

  Parallel Scavenge收集器是一个新生代收集器，使用复制算法，并行的多线程收集器。
  Parallel Scavenge目标是达到一个可控制的吞吐量。吞吐量=运行用户的代码/（运行用户的代码+垃圾收集时间）
  Parallel Scavenge提供了俩个参数用于精确控制吞吐量
  最大垃圾手机停顿时间: -XX:MaxGCPauseMillis
  吞吐量大小-XX:GCTimeRato

- Parallel Old

  Parallel Scavenge的老年代并行版本 标记整理

- CMS

  ConCurrent Mark Swap 第一款并发版本的垃圾收集器。是一种获取最短停顿时间为目标的收集器。
  集中在互联网网站和B/S架构的服务端上。整个过程分成4个步骤
  基于标记-清除。
  
  缺点:
  1.CPU资源敏感，默认启动的线程数是(CPU数量+3)/4，当CPU数量不多时，可能会导致用户执行线程速度下降。
  2.空间碎片，因为标记-清除。可以设定指定多次不压缩的Full Gc之后带来一次压缩的。
  3.无法处理浮动垃圾 并发清理的时候运行的线程也在运行，这个时候产生的垃圾无法被处理。 可以设定老年代的大小触发GC的百分比。 -XX：CMSInitationOccupancyFratcion的值提高触发的百分比

	- 初始标记

	  Stop The World。标记GC Roots关联到的对象，速度很快

	- 并发标记

	  GC Roots 遍历的过程

	- 重新标记

	  修正并发标记期间用户程序运作导致的对象变化的内容

	- 并发清除

- G1

  GarBage-First收集器是当今收集器里程碑的成果。开创了收集器面向局部收集的设计思路和基于region的内存布局形式。
  构建一个在长度为M毫秒的时间片段、消耗在垃圾收集上的时间大概率不超过N毫秒的目标。
  1.并发与并行。充分利用多CPU、多核环境下的硬件优势、使用多个CPU减少Stop the World的时间
  2.分代收集
  3.空间整合
  4.可预测停顿
  G1收集器将Java堆内存布局进行划分成多个大小相等的独立区域(Region)，保留新生带和老年代，它们都是一部分Region集合
  G1收集器中Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用。避免全堆扫描，m每个region中都会有对应的Remembered Set,虚拟机发现程序在对Refernce类型的数据进行写操作时，会产生一个Write Barrier暂时中段写操作，检查引用是否在不同的region当中

	- 初始标记

	  标记GC roots关联的对象。需要停顿用户线程

	- 并发标记

	  和用户线程并发。从GC Root开始对堆中对象进行可达性分析，递归扫描整个对象里的对象图，找到要回收的对象。重新整理SATB记录的内容

	- 最终标记

	  对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后的STAB记录。

	- 筛选回收

	  对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿时间来指定回收计划。这部分涉及存活对象的移动，是必须暂停用户线程，由多条收集器并行完成。

- Shenandoah

  OpenJDK才有的垃圾收集器。
  在OracleJDK12中不支持

- ZGC

  实验性质的低延迟垃圾收集器。目前支持Linux/x86-64

### 3.5  内存分配与回收策略

- 3.5.1  优先在Eden分配

  大多数情况，对象在Eden区分配。当Eden区没有足够的空间进行分配时，虚拟机会进行一次MinorGC。

- 3.5.2  大对象直接进入老年代

  大对象就是指需要大量连续内存空间的Java对象，最典型的大对象就是很长的字符串。
  可以通过设定参数-XX：PretenureSizeThreshold参数大于这个大小的直接分配在老年代

- 3.5.3  长期存活对象进入老年代

  在新生代当中的对象熬过一次Minor Gc年龄会加一，经过15次时候会被放入到老年代。

- 3.5.4  动态对象年龄判定

  如果在Suvivor的对象相同年龄的对象占具Suvivor对象的一半，会把这些内容直接放入老年代

- 3.5.4  空间分配担保

  发生Minor GC(young GC) 发生GC之后新生代 Survivor1无法放入的对象会被放到老年代当中。老年代的空间进行担保。
  GC之后会进行检测是否老年代中是否够放，不够就会触发一次Full GC。

## 4.虚拟机性能监测与故障处理工具

### jps

jps [options] [hostid]
JVM Process Status Tool 显示指定系统内所有的HotSpot虚拟机进程
jps也可以查询开启服务的虚拟机进程状态，参数Hostid为注册的主机名。

### jstat

jstat [option vmid[interval[s|ms] [count]]]

JVM Statistics Monitoring Tool,用于收集HotSpot虚拟机各方面运行时的数据

### jinfo

jinfo [options] pid
Configuration Info for Java 显示虚拟机配置信息

### jmap

jmap [options] vmid
还可以查询finalize执行队列，Java堆和方法区的详细信息，如空间使用率，当前使用那种垃圾收集器。
Memory Map for Java 生成虚拟机的内存存储快照

### jhat

JVM Heap Dump Browser 用于分析heapdump文件，会创建一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果

### jstack

Stack Trace for Java 显示虚拟机的线程快照

### VisualVM 多合一故障处理工具

显示虚拟机进程以及进程的配置、环境信息。
监视应用程序的处理器、垃圾收集、堆、方法区、以及线程的信息(jstat、jstack)
dump以及分析堆转存储快照
方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。

## 5.虚拟机类加载机制

### 5.1  类加载

类被加载到虚拟机内存的生命周期有。加载，验证，准备，解析，初始化，使用，卸载

- 5.1.1  加载

  Java虚拟机规范中并没有进行强制约束，交给虚拟机的具体实现来把握

	- 通过一个类的全限定名来获取定义次类的二进制流
	- 将这个字节流转化为方法区的数据结构
	- 在内存中生成一个代表这个类的对象，作为方法区这个类的访问入口。

- 5.1.2  验证

  确保class文件的字节流中包含的信息符合虚拟机的要求。并且不会危害虚拟机的安全

	- 文件格式验证
	- 元数据验证
	- 字节码验证
	- 符号引用验证

- 5.1.3  准备

  准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量的内存都将在方法区中进行分配，将对象赋值为对应的0值

- 5.1.4  解析

  解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
  符号引用用一组符号表示引用的目标。
  直接引用是直接指向目标的指针
  类或接口的解析

	- 接口方法解析
	- 字段解析
	- 类方法解析

- 5.1.5  初始化

  类加载过程的最后一步骤，在初始化阶段。执行类加构造器<clinit>方法的过程

- 5.1.6  使用
- 5.1.7  卸载

### 5.2  类加载器

- 5.2.1  类与类加载器

  类加载器用来实现类的加载动作。
  判断俩个类相等，需要判断类是否相等，判断俩个类的加载器是否一样

	- 启动类加载器(Bootstrap ClassLoader)
	- 扩展类加载器(Extension ClassLoader)
	- 应用程序类加载器(Application classLoader)
	- 自定义类加载器

- 5.2.2  双亲委派模型

  如果一个类加载器收到了类加载的请求，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有加载请求最终都会传到顶层的启动类加载器。只有父加载器反馈无法完成这个加载请求，子加载器才会方式自己去加载。
  好处：保证对象类在程序当中都是同一个类，如果各个类加载器去自行加载，就会导致产生多个相同名称，不相等的类

- 5.2.3  热修复

## 6.程序编译与代码优化

### 6.1  注解处理器

### 62  语义分析与字节码生成

- 标注检查
- 数据及控制流分析
- 解语法糖
- 字节码生成

### Java语法糖

- 泛型与类型擦除

  没引入之后，把类型转化交给程序员，把ClassCastException
  泛型是在JDK1.5引入的新特性。
  Java语言的泛型只存在程序源码中，在编译后的字节码文件，已经被替换为原声类型。并在相应的地方插入强制转化。

- 自动装箱，拆箱 遍历循环
- 条件编译

### 运行期优化

## 7.高效并发

并发处理，提高计算机的运算能力

### 7.1  Java内存模型与线程

- 7.1.1 Java内存模型

  主要目标是定义程序中各个变量的访问规则。规定了主内存和每条线程的工作内存

	- 主内存和工作内存

	  工作内存会首先从主内存当中取值

	- 内存间的交互操作

	  8个内存模型的原子操作
	  1.不允许read和load、store和write操作之一单独出现。
	  2.不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把改变化同步到主内存。
	  3.不允许一个线程无原因地把数据从工作线程写入到主内存中
	  4.一个新的变量只能从主内存中"诞生"，不允许工作内存直接使用一个未被初始化的变量
	  5。一个变量在同一时刻只允许一条线程进行lock操作
	  6.变量执行lock操作，会清空工作内存中此变量的值。在使用这个变量前，需要重新执行load或assign操作变量的初始值
	  7.一个变量没有被lock,不允许unlock
	  8.unlock之前必须把数据写入到主内存

		- lock(锁定)

		  作用于主内存的变量，它把一个变量标识为一条线程独占的状态.。。。。。。

		- unlock(释放)

		  作用于主内存的变量，把一个处于锁定的状态的变量释放出来，释放后的变量才可以被其他线程锁定

		- read(读取)

		  作用于主内存的变量，它把一个变量的值从主内存传输到线程工作的内存，以便随后的load动作使用

		- load(载入)

		  作用与工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中

		- use(使用)

		  作用于工作内存的变量，把工作内存中的一个变量的值传递给引擎，每当虚拟机遇到一个需要使用的变量的值的字节码指令时将会执行这个操作。

		- assign(赋值)

		  作用于工作内存的变量，它把一个执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个变量赋值的字节码指令执行这个操作

		- store(存储)

		  作用于工作内存内，把工作内存的一个值写入到主内存中，以便随后的write操作使用

		- write(写入)

		  作用于主内存，它把store操作从工作内存取到的变量的值写入到主内存的变量中。

	- volatile

		- 可见性

		  从物理存储角度来看，各个线程的工作内存中volatile变量，每次使用之前都要进行刷新，因此保证了可见性。

		- 禁止指令重排

		  指令重排是指处理器采用了允许将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理。
		  流水线操作，允许指令进行多个电路单元去执行。

		- 不保证原子性

		  误区：不要认为一条字节码指令就是一个原子操作。

	- 先行发生

	  i=1 ;//线程A
	  
	  j=i；//线程B
	  
	  i=2; //线程C
	  这个三个线程执行会发生不确定性的结果

		- 程序次序原则
		- 管程锁定原则
		- volatile变量规则
		- 线程启动原则
		- 线程终止原则
		- 线程中断原则
		- 对象终结原则
		- 传递性

- 7.1.2  线程

	- 使用内核线程实现

	  直接由操作系统内核执行的线程，
	  这种线程由内核来完成线程的切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。
	  程序一般不会使用内核线程

	- 使用用户线程实现

	  一个线程只要不是内核线程，就是用户线程。
	  轻量级的进程也是属于线程。用户线程的建立，同步，销毁和调度完全由用户态执行支持规模大的线程数量。

	- 使用用户线程和轻量级进程混合实现

	  用户线程和轻量级进程混合使用。N:M关系

	- Java线程的实现

	  sun JDK 一条Java线程映射到一条轻量级进程

		- 线程调度

			- 
协同式调度

			  一个线程决定自己执行多久。工作完之后同时其他线程。
			  实现简单。
			  缺点是 相当不稳定，一个线程不让出资源，其他都会阻塞

			- 抢占式线程调度

			  由系统分配执行时间，通过设置优先级表示抢占的之后的执行时间

		- 线程状态

			- 新建

			  创建尚未启动

			- 运行

			  有可能在执行，也可能在等待CPU为它分配时间

			- 无限期等待

			  不会被分配执行时间，要等待被其他线程显式的唤醒。
			  没有Timeout参数的Object,wait()
			  没有Timeout参数的Thread,join()
			  LockSupport.park()方法

			- 限期等待

			  不会被CPU分配执行时间，不需要等待其他线程显式唤醒。在执行一定时间之后会由系统自动唤醒。
			  Thread.sleep()
			  设置参数的Object.wait()
			  设置参数的Thread.join()
			  LockSupport.parkNanos()
			  LockSupport.parkUntil()

			- 阻塞

			  等待获取一个排他锁

			- 运行

			  执行结束

		- 协程

### 线程安全与锁优化

- 线程安全

  当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

	- 互斥同步(悲观)

	  互斥是保证同步的方法(悲观锁)
	  问题是线程组合和唤醒带来的性能开销
	  悲观锁：认为数据会有很多写操作，无论是否存在竞争，总是不安全的，每次都要进行加锁。

		- 临界区
		- 互斥量
		- 信号量
		- synchornized
		- lock

	- 非阻塞同步(乐观)

	  乐观的同步措施。(乐观锁)
	  乐观锁：认为数据的操作不会不安全，失败之后进行重试。

		- 测试并设置
		- 获取并增加
		- 交换
		- 比较并交换CAS

		  Unsafe类下提供的方法。
		  compareAndSwapInt()和
		  compareAndSwapLong()

			- 底层AQS

		- 加载链接/条件存储

	- ;无同步方案

	  如果一个方法本来就不设计共享数据无需同步措施去保证正确性，有一些代码天生就是线程安全的

		- 可重入代码
		- 线程本地存储

- 锁优化

  互斥同步的最大性能消耗是挂起线程和恢复线程操作都需要转入到内核态，给操作系统带来压力。

	- 自旋锁与自适应自旋

	  可以设置参数设定自旋次数

	- 锁消除

	  虚拟机检测到不可能存在共享数据竞争，会把锁进行消除。

	- 锁粗化

	  一系列操作对一个对象的反复加锁和解锁，即使没有线程竞争，频繁执行互斥同步操作导致不必要的性能消耗。
	  如StringBuilder的append方法。

	- 轻量级锁

	  如果存在锁竞争，除了互斥开销，还发生了CAS，轻量级锁比传统的重量级锁更慢

	- 偏向锁

	  消除无竞争状态下的同步原语。
	  锁会偏向第一个获取它的线程。
	  如果存在另外一个线程获取，再进行线程同步控制。

## JVM 相关面试题

### 1.一个方法执行完之后JVM会做什么处理

- 虚拟机栈中栈帧空间回收
- 该方法返回地址入栈
- 局部变量表重置
- 操作数栈表重置
- 程序计数器重置

### 2.同步指令synchorized 在JVM层面上的理解

Java虚拟机使用管程支持同步的。
虚拟机可以从方法的常量池的方法表结构中的ACC_SYNCHORNIZED的访问标识判断方法是否是同步方法

当方法调用时，调用指令将会检查ACC_SYNCHRONIZED访问标志是否被设置了，如果设置了，执行线程就要求先持有管程，执行线程持有了管程，其他任何线程无法再获取同一个管程。如果一个同步方法出现了异常，这个管程将在异常抛到同步方法之外时自动释放。

同步一端指令集序列通常是由Java语言中的synchornized语句块来表示，Java指令集中有monitorenter和monitorexit俩条指令来支持synchronized关键字的语义。

